package com.sist.main;
/*
  	 메모리구조
  	---------------------
  	 MethodArea , static => 컴파일러에 의해 자동 저장
  	 method도 메모리에 저장된다
  	 void method() => 메소드가 선언만 되어있는 경우에는 클래스를 저장하지 않음(미완성된 클래스) => 추상클래스 , 인터페이스
  	 {
  	 } => 메소드는 구현부가 있어야 저장된다
  	 메소드가 선언만 되어있는 경우에는 클래스를 저장하지 않음(미완성된 클래스) 
  	 => 추상클래스 , 인터페이스 => 요구사항 분석
  	 			  --------
  	 			  데이터베이스 연결 , 윈도우 작업 , 네트워크 서버접속 ,
  	 			  웹 구현 등에 주로 사용
  	 void method(); => 사람마다 사용자 구현방식이 다르기 때문에 선언만 한다
  	---------------------
  	 Stack : LIFO/리포(last-in, first-out)/ 나중에 들어온게 먼저 빠져나가는 방식
  	 	     지역변수, 매개변수가 저장되는 위치 => 메모리 자체에서 관리됨({}블록이 끝나면 사라진다)
  	 	     class A
  	 	     {
  	 	     	void method()
  	 	     	{
  	 	     		int a=10;
  	 	     		if(a%2==0)
  	 	     		{
  	 	     			int b=20;
  	 	     			if(b==20)
  	 	     			{
  	 	     				int c=30;
  	 	     			} // c 1등
  	 	     		} //b 2등
  	 	     	} //a 3등
  	 	     }
  	---------------------
  	 Heap : 동적메모리 할당 시 저장되는 공간(읽을떄마다 할당되는 공간) => 객체 변수들이 저장된다(배열 등) (참조변수값)new해서 들어가는 값들은 다 Heap에 들어간다
  	 	    => 프로그래머가 관리하는 공간 => 관리 소홀 시 가비지콜렉터 작동(GC/자동메모리 회수)
  	 	    						=> 프로그래머는 급할때 객체에 null값을 주면 데이터 비우기 가능
  	  A.java ==> A.class ===> 
  	       javac        java
  	  class A ==> 인터프리터를 이용, 한줄씩 번역(읽고출력)해나가는 방식- 위에서 아래로 순서대로 하다가 new가 나오면 메모리할당
  	  {
  	  	---
  	  	---
  	  	---new
  	  	---
  	  	---
  	  }
  	---------------------
   일반 변수는 => Stack에 저장
           int a=10;
   		0--------------
   		  사용중
   		4--------------
   		  사용중
   		8--------------
   		 ==> 남은 공간에 값 채움 = 10; ==> 데이터가 얼마나 남은지/ 남는 공간이 어디인지 저장공간을 찾을 수 없으니까 메모리 주소에 대한 별칭을 주는것: a
   		12--------------
   		
   배열 
   		=> 직렬로 저장되기 때문에 모든 값들이 크기가 같아야함 (공간이 동일한 크기로 나뉨)
   		-------------------------------
   		| 	|	|	|	|	|	|	|
   		-------------------------------		
   클래스
   		=> 병렬로 되어있기 때문에 값크기가 달라도 저장 가능함/ 메소드도 가능
   		-----------------
   			1
   		---------------------
   			"홍길동"
   		---------------
   			"남자"
   		-----------------
   		   getName()
   		------------------
   		   getSex()
   		------------------
   
 클래스
 1. 구성요소
 	1)변수 (*****)
 		= 인스턴스변수 : 객체마다 메모리를 따로 저장(계속 쓸 애들은 여기에)
 					 => new를 이용해서 메모리 저장공간이 만들어진 경우
 		  A a=new A()
 		  - 인스턴스 (객체)
 		  사용법) a.변수명 
 		= 정적변수 : 메모리 공간이 한 개를 사용한다 (=공유변수,클래스변수)
 		  - static => 컴파일 시 자동으로 생성됨
 		  사용법) 클래스명.변수명
 		= 멤버변수 ? 
		---------------------------↓ 메소드 호출 시에 생성 ↓-----------------------------------
 		= 지역변수 : 기능 처리에 필요한 데이터를 설정, 메소드 종료와 동시에 사라짐 (쓰고 버리는 애들은 여기에)
 		= 매개변수 : 사용자 요청값, 메소드 종료와 동시에 사라짐
 		   ====> 변수는 반드시 초기화 후에 사용한다
 		   				   -----
 		   				자동 초기화 되는 경우: 클래스 영역에 선언된 변수
 		   								  인스턴스, 정적변수는 초기화됨.
 		   				초기화가 없는 경우: 지역변수 , 매개변수
 	  class A
 	  {
 	  	String addr;// 전역변수를 잡는다
 	  	void Address(사용자가 String addr을 받고)
 	  	{
 	  		this.addr=addr;	// 전역변수는 메소드 여러곳에서 사용하는걸 말한다
 	  	}
 	  	void 지도출력()
 	  	{
 	  		addr;
 	  	}
 	  	void 근처맛집()
 	  	{
 	  		addr;
 	  	}
 	  }
 	2)메소드 => 명령문의 집합체 => 단락(구조적인 프로그램)
 			   반복수행(제거) => 재사용을 목적으로 하기 때문에 한가지 기능을 수행하는 편이 좋다
 			   다른 클래스와 통신 담당(like getter/setter)
 	  1. 종류
 	  	 인스턴스메소드 : 따로 작동하는 메소드/ 문자열마다 따로따로 제어를 해야할때
 	  	 	String s="Hello Java";
 	  	 	s.substring()
 	  	 	String s1="Hello Oracle";
 	  	 	s1.substring()  //제어대상.클래스
 	  	 정적메소드 : 동시에 움직일 때 (똑같은 일을 동시에 작동할때) / static 메소드 => 자동으로 저장된다는 장점
 	  	 	10(숫)=> "10"(문), true=>"true"	//제어하는 대상이 없을때 
 	  	 	String.valueOf(데이터형)	
 	  	 	Math.random()
 	  	 추상메소드 : 설계 => 모든 개발자가 같은 메소드를 제어
 	  	 			  => 표준화 작업 
 	  	 			  => 여러개의 클래스를 묶어서 한개의 이름으로 제어
 	  	     동물 => 먹는다 , 걷는다 ... 기능 선언; 
 	  	     |
 	  	  ---------
 	  	  |   |   |		
 	  	 인간  개   말 ... => 변수마다 기능 구현법이 다름
 	  	 
 	  	 종단메소드 : final void aaa(); => 상수형 메소드이기때문에 변경할 수 없는 메소드(확장XXXX) 사용빈도 낮음
 	  
 	3)생성자
 		= 객체 생성 시 호출되는 메소드
 		= 멤버변수의 초기화를 담당
 		= 특징) 클래스명과 동일해야함, 리턴형 없음, 생성자는 여러개 존재할 수 있음(오버로딩/같은메소드,다른기능)
 		= 클래스 안에 생성자를 반드시 구현하는 것은 아니다
 		  = 생성자가 없을 시 기본 생성자를 추가한다 (매개변수가 없는 생성자)
 	<클래스를 만들때 쓰는 형식>
 	= 변수만 모아서 관리 : 사용자 정의 데이터형(~VO ~DTO ~Bean)
 		getter/setter는 메소드(변수의 기능: 읽기/쓰기)
 	= 메소드만 모아서 관리 : Action Class
 						대표적으로 ~System ~DAO ~Manager ~Service
 	= 변수+메소드 처리 : 조립할때 많이 사용
 					 ~Model ~Controller(Spring) ~Action(Structure)
 2. 클래스 설계
 	1. 기능 설계/벤치마킹 : 메소드 추출 (기능)  
 	2. 기능에서 사용하는 변수를 추출
 	3. 클래스 설계
 		class ClassName
 		{
 		  변수 
 		  메소드 
 		  생성자
 		}
 	4. 메모리에 저장
 		ClassName c=new ClassName();
 		
 	5. 활용
 		c.메소드..
 	6. 소멸
 		c=null;
 	 -끝- 
 3. 접근지정어
 	-------------------------------------------------------------
 	 private : 자신의 클래스에서만 접근이 가능 => 데이터보호 목적(캡슐화 코딩)
 	-------------------------------------------------------------
 	 default : 같은 패키지 안에서만 접근 가능
 	-------------------------------------------------------------
 	 protected : 같은 패키지 안에서만 접근 가능(상속이 있는 경우 다른 패키지 접근 가능)
 	-------------------------------------------------------------
 	 public : 패키지 상관없이 모든 클래스에 접근 가능
 	-------------------------------------------------------------
 	 멤버변수	[접근지정어] 데이터형 변수형
 	 메소드 [접근지정어] [제어어] 리턴형 메소드명(매개변수목록)
 	 				 -----static , abstract , final
 	 		{
 	 		}
 	==>  변수 : 보통 private을 씀
 		 메소드 : 통신 담당이니 public을 기본으로 붙임
 		 생성자 : public
 4. 객체지향의 특성
 	1) 캡슐화 과정 => 데이터 은닉화(다른 곳에서 침투못하도록)한 후 메소드 통해서 접근 가능
 					----------private               -----getter/setter
    2) 재사용 기법 = 상속 (is-a) 
    			  기존의 기능을 변경해서 사용
    			  ** 개발자들이 오버라이딩을 꺼리는 이유: 안에 뭐가 들었는지 모르니 오류날까봐
    				class A
    				{
    				}
    				class B extends(확장) A => 단일상속
    				{
    				}
    			= 포함 (has-a)
    		      기존의 기능을 있는 그대로 사용
    		      	class A
    		      	 {
	    		     }
	    		     class B
	    		     {
	    		      	A a;
	    		     }
    3) 수정 			/ 추가 => 다형성
       |	 		   |    
   		오버라이딩 	/ 오버로딩
    -------------------------------------------------------------------------
     메소드명 동일
    -------------------------------------------------------------------------
     상속관계			한개 클래스 / 상속 관계
    -------------------------------------------------------------------------
     매개변수 동일 		매개변수의 갯수/데이터형
    -------------------------------------------------------------------------
     리턴형 동일
    -------------------------------------------------------------------------
 	 접근지정어 확장
 	 	기능 수정			새로운 기능 추가
    -------------------------------------------------------------------------
 
 5. 제어자
    static / abstract / final 
    => static final : 상수
    => final : 상수형 변수 => 메소드안에서 사용 가능
       ------사용하는 위치 (오라클 주소, 계정명, 비밀번호)
 
 */
public class 객체지향정리 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

	}

}
