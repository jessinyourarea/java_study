package com.sist.exception;
/*
 * 	final 클래스=> 종단 클래스 (java.lang)
 * -----------------------
 * 			확장해서 쓸 수 없음, 있는 그대로 사용함. ==> 상속을 내리지 못한다=상위클래스가 될 수 없다
 * 	대표적인 예) String, Math,System
 * ---------------	
 *  java.lang
 *  java.util
 *  java.io
 *  java.net
 *  java.text
 *  -------------기본 라이브러리
 *  java.sql , javax.http.servlet.* javax.xml...
 *  오라클        브라우저
 *  
 *  4. 오버라이딩 (상속의 기본) => 변경해서 사용하는 다형성이 특징
 *  	객체지향의 3대 요소
 *  	  1. 데이터 보호 목적
 *  		 캡슐화 : 변수를 은닉화시켜 => 메소드를 통해 접근 가능할 수 있게
 *  				------------               ---------
 *  			  	  private				    public
 *  				=> 변수는 2가지 기능만 수행
 *  					메모리 저장/ 메모리에서 데이터 읽기
 *  			        -------    ---------------
 *  					Setter		Getter
 *  				  => 모든 멤버변수들을 private으로 감추고
 *                    => 모든 메소드(생성자포함)들은 public을 주어 다른 클래스와 연결 가능하도록
 *  	  	 접근지정어
 *  		--------
 *  		1) private	: 자신의 클래스에서만 사용 가능 (은닉화)
 *  					  다른 클래스에서는 접근 불가능
 *  		2) default : 같은 패키지 안에서만 사용 가능
 *  		3) public : 공개(패키지 상관없이 모든 클래스에 접근 가능)
 *  	  2. 재사용하는 목적 : 상속 , 포함  ==> 클래스 크기 결정 => 형변환 가능
 *  		class A
 *  		class B extends A => A가 가지고 있는 모든 내용을 가지고 온다는 뜻
 *  		        ------- A의 내용을 변경해서 사용,추가 가능 
 *  						라이브러리에 나온 내용이 프로그램에 맞지 않는 경우 수정.
 *			===============> A(상속을 내린 클래스) > B(상속을 받은 클래스)
 *			  => A a=new A()
 *				 B b=new B()
 *				 A c=new B()	=> 묵시적 형변환 (자동)
 *			       -------> 추상클래스/인터페이스 에서는 메모리 할당이 안된다
 *							 --> 메모리 할당 시에 상속받은 클래스를 이용해서 메모리 할당(구현)
 *								  ==미완성 클래스 (메소드가 구현안된상태)
 *								=> 설계 , 같은 기능 (처리를 프로그램에 맞게 할 때)
 *
 *				 B d=(B)c;		=> 명시적 형변환 (강제)
 *				클래스를 저장해서 관리하는 클래스 => Collection
 *				'A' 'BBBBB'
 *				1byte 5byte ==> 크기를 자동으로 확인해서 저장공간을 할당하는 기능 
 *					
 *  		class A
 *  		{
 *  		  B b=new B(); // 특별한 경우가 아니면 재정의하지 않는다  ==> 기능을 그대로 가져다쓰고 싶을 때
 *  		}
 *  		class B
 *  	  3. 수정 , 추가 목적 (유지보수)
 *  		수정(오버라이딩) 추가(오버로딩) => 메소드 관련
 *  		> 조건표
 *  		-----------------------------------------------------------------------
 *  						오버로딩			오버라이딩
 *  		-----------------------------------------------------------------------
 *			 관계  			1개의 클래스		상속관계
 *							상속 관계
 *  		-----------------------------------------------------------------------
 *   		 메소드명			동일해야함			동일해야함
 *  		-----------------------------------------------------------------------	
			 매개변수			갯수나			동일해야함
			 			데이터형이 달라야함
 *  		-----------------------------------------------------------------------
 *  		 리턴형			관계없음			동일해야함
 *  		-----------------------------------------------------------------------
 *  		 접근지정어		관계없음			확장은 가능함
 *  		------------------------------------------------------------------------
 *  		 (주)사용처		생성자			인터페이스/추상클래스
 *  		-------------------------------------------------------------------------
 *  		***상속
 *  		1) 호출 ==> 상위클래스의 생성자가 먼저 호출 (기본생성자가 꼭 있어야함)
 *  			class A
 *  			{
 *  				=> public A(){}
 *  				public A(int a){}
 *  			}
 *  			class B extends A
 *  			{
 *  				public B(int a,int b){}
 * 				}
 * 
 * 				B b=new b();
 * 					=> new A() => new B()
 *  		2) 예외조건 ==> static 생성자 초기화블록 , private
 *  
 *  		 ===> 생성자 형을 맞추지 않으면 ClassCastException 오류가 뜸.
 *  	클래스의 종류
 *  	= 추상클래스
 *  	= 인터페이스 => 추상 클래스의 단점을 보완해주고, 클래스와 동일하게 취급
 *  		** 클래스(단일) / 인터페이스(다중)의 차이
 *    공통점---- 설계도(구현이 안된 상태) =>미완성 클래스 (자신이 메모리 할당을 못함)
 *  	  ---- 여러 개의 관련된 클래스를 모아서 한개의 객체명으로 제어
 *  	-----------------------------------------------------
 *  					추상클래스 			인터페이스
 *  	------------------------------------------------------
 *  	 상속관계    		단일상속				다중 상폭
 *  ---------------------------------------------------------
 *  	 상속키워드		extends				implements
 *   	-----------------------------------------------------
 *   	 멤버변수			인스턴스변수			상수형 변수만 
 *   					정적변수 사용 가능		사용 가능
 *   --------------------------------------------------------
 *   	 메소드		   구현된 메소드			구현이 안 된 메소드
 *   				  구현이 안 된 메소드	   					
 *   -------------------------------------------------------
 *   	  기법			오버라이딩				오버라이딩
 *   ---------------------------------------------------------	
 *  	  형식 		
 *  			추상클래스
 *  		[접근지정어] abstract class ClassName
 *  		{
 *  			-------------------------------
 *  			변수 
 *  				인스턴스변수
 *  				static변수
 *  			-------------------------------
 *  			메소드
 *  				구현된 메소드
 * 				
 * 				구현이 안된 메소드(선언)
 * 				[접근지정어] abstract 리턴형 메소드명(매개변수..);
 *   -----------------------------------------------------------
 *   			생성자 , 오버로딩 가능
 *   ----------------------------------------------------------
 *		인터페이스
 *		[접근지정어] interface Interface명{
 *	       ------------------
 *			변수선언(상수형 변수)
 *			int a=10; > 값을 명시적으로 저장
 *			=> public static final int a=19;
 *			------------------
 *			구현이 안된 메소도 목록
 *			void display();
 *				=> public abstract void display();
 *  		구현한 메소드 명록
 *  		default 메소드 
 *  		--------------------
 *  		구현한 메소드 목록 
 *  		default void aaa(){}
 *  		=> 컴파일 돌리면 public default void aaa(){}로 해석할 것이다
 *  		static void bbb(){}
 *  		=> 인터페이스는 변수나 메소드가 public(연결 목적: 언제든 연결 가능하게)
 			
 			상속	
 					
 			interface 끼리의 상속  ==> extends사용
  			interface > class 상속 ===> implements사용
  			다중 상속 시에
  				class A implements 인터페이스,인터페이스 .....
 */
import java.util.*;
class AAA
{
	public void aaa() {}
	public AAA() {}
	int a=10;		//순서는 상관없음 (멤버변수/생성자/메소드)
}
class A
{
	int a=10;
	String name="홍길동";
	public A() {}
	public A(int a) {
		this.a=a;
	}
}
class B extends A
{
	int b=20;
	public B()
	{
		super();	//==public A(){}
 	}
}
/*
 *  하위클래슨에서 추가된 메소드와 변수는 사용할 수 없다
 *  B b=new B()
 */
public class 정리_7장{

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		//B b=(B)new A(); ==> 오류
		String s1="Hello";
		String s2="Hello";
		String s3=new String("Hello");
		
		if(s1==s2)
			System.out.println("같다(참조주소)");
		
		
		Object o=new AAA();
		AAA a=(AAA)o;
		
	}

}
