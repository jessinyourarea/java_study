package com.sist.main;
/*
 	1) 네트워크 프로그램 
 	2) 데이터베이스 프로그램(웹)
 	--------------------------Spring
 	데이터베이스는 데이터 저장 장소
 	----------------------->자바에서 읽기(메모리에 저장 및 제어)
 	1. 메모리에 저장 : 변수 => 제어 (제어문,연산자)
 	2. 데이터가 많은 경우
 		= 같은 데이터형 : 배열
 		= 다른 데이터형 : 클래스 (***)
 	3. 클래스
 	    = 클래스 정의 방법 (객체지향프로그램 => 한개의 클래스로 만드는 것이 아니라
 	    				클래스와 클래스의 연관관계 => Spring(DI) dependency injection)
 	    				행위자 (웹:사용자, 관리자)
 		*** 접근지정어 (권한 부여~ 어디까지 접근할 건지 지정하기)
 		private : 자신의 클래스에서만 사용 가능 => 은닉화(캡슐화)
 				  => 목적: 데이터 보호 
 				  => 변수(클래스의 속성)
 				  => private 데이터형 변수명
 				     -------------------
 		default : 같은 패키지안에서만 사용 가능
 				  => 윈도우나 Thread(프로그램 안에서 여러개의 프로그램을 수행) 만들때 가끔 등장
  				     게임: 총알 , 비행기 ...
  		protected : 같은 패키지 안에서만 사용 가능
  					단, 상속을 받은 경우 다른 패키지까지 접근 가능
  					=> 사용 빈도가 거의 없다
  					=> 상속을 내리면 모든 변수,메소드 사용 가능
  					  private 변수는 접근 불가능!
  					  -------------------------------- protected
  		public : 모든 클래스에서 접근 가능
  				 클래스 : 연관관계 => 다른 클래스에서 접근 가능
  				 생성자 : 다른 클래스에서 메모리 할당 후 사용 
  				 메소드 : 다른 클래스와 통신 담당
  		-======> private public 을 주로 쓴다
  		-------------------------------------------접근지정어-----------------------------------
  		private < default < protected < public (****)
  		=> 오버라이딩: 접근지정어의 확장O, but 축소X
  		상속의 존재 이유: 똑같이 가져다 쓰려면 클래스를 부르면 되지만, 실정에 맞게 변경할떄도 있기 떄문에 기능을 바꿔줘야 한다
  		예) 한글은 깨진다 (브라우저 : C언어로 만둚 - char(1byte) / 왜? vs 한글은 2byte(Unicode)를 쓰고 있기 때문에
  										ASC								=> 우리는 이걸 변환하는 방법을 배워야한다!
  										
  		   class A
  		   {
  		     public void display(){}
  		   }
  		   class B extends A		// 상속
  		   {
  		   	 void display(){}		// !!오류!! public > default 가 될 수 없다!!
  		   }									만약 default > public 이라면 가능하다
  			상속 : 반복제거
  			class A
  			{
  			  int a,b,c,d,e;
  			}
  			class B extends A
  			{
  			  // int a,b,c,d,e,;
  			}
  			--------------------------------------------------------------------
  			클래스의 구성 요소: 벤치마킹 ===> 요구사항 분석'
  			class ClassName
  			{
  			  ------------------------------------
  			   속성, 필드 => 멤버 변수 (캡슐화) ==> 다른 클래스에서 사용 가능하게 만든다
  			     		   -------------------읽기/쓰기 메소드
  			     		   					  getter/setter => instance method
  			   공유변수 (static) : 패턴 (싱글턴) => 한개의 객체만 사용
  			           ------ 메모리 공간이 한 개 
  			           ------ 공유하는 데이터가 존재할땐 꼭! static! 예시)MemberSystem/UserMain 
  			  -------------------------------------
  			   생성자 
  			    1. 클래스명과 동일
  			    2. 멤버변수에 대한 초기화 
  			    3. 생성자가 없는 경우에는 자동으로 컴파일러가 기본생성자(매개변수가 없는)를 추가한다
  			    
  			    예)
  			    class A
  			    {
  			      //public A(){}
  			    }
  			    class A
  			    {
  			      public A(){}
  			    }
  			    4. 모든 클래스는 생성자는 1개 이상을 가지고 있다
  			    5. 생성자는 객체를 생성할 때 호출되는 메소드
  			    	사용법) 앞에 new 를 붙인다: 형식)new 생성자();
  			    6. 리턴형은 존재하지 않는다 
  			    7. 생성자는 필요시에는 여러개를 만들 수 있다
  			       ---------------------------------
  			       오버로딩을 지원 (중복메소드 정의)
  			       한개의 메소드 이름으로 여러개 기능을 생성
  			       ** 오버로딩 VS 오버라이딩 
  			           new      modify
        (기존 기능으로 새로운 기능을 만드는것) (덮어쓰기)     
  			       ----
  			       오버로딩
  			       조건)
  			       1) 메소드명이 동일
  			       2) 한개의 클래스에서 만든다
  			       3) 매개변수의 갯수나 데이터형이 다르다
  			       4) 리턴형은 무엇이 오든 관계없다
  			     예)
  			     	class A
  			     	{
	  			     	//A(){} ==> 기본 생성자는 자동 추가되지 않는다/이미 다른 생성자들이 있기 떄문에
	  			     	A(int a){}
	  			     	A(double d){}
	  			     	A(int a,int b){}
	  			     }
	  			     A a=new A(); ==> 오류 발생/why? 디폴트 생성자가 없기 때문에 오류 발생!!
	  			     
	  			     **생성자는 초기화 담당. 
	  			       그러나 그 외의 기능=> 시작과 동시에 처리하는 일이 있는 경우
	  			       윈도우디자인 , 웹 메인 이용 시..
	  			       자동 로그인 , 오라클 연결 , 서버 연결 담당 ..
	  			       => 가장 먼저 호출되는 메소드가 생성자. 
	  			       
	  			 ** new (객체 생성 방법)
	  			    class A
	  			    
	  			    1) A a=new A();
	  			    ----------------------------------------
	  			    2) A a=Class.forName("A").newInstance()
	  			    3) A a=A.newInstance()
	  			    ---------------------------------------- ==> reflection(스프링에서 주로 사용)
  			       
   			  --------------------------------------
  			   메소드: 기능 수행, 다른 클래스와 연결 
  			   메소드 제작 방법 (형식)
  			    [접근지정어(public)][제어어] 리턴형 메소드명(매개변수목록) ==> 선언부
  			    {
  			    	==> 구현부
  			    }
  			    
  			    1. 선언부
  			       = 접근지정어 : public , default
  			       = 제어어 : static , final , abstract
  			       	 static : public static
  			       	  		  => 객체마다 공통으로 사용되는 기능
  			       	 final : public final => 오버라이딩이 안되는 상태
  			       	 		 => 수정이 불가능
  			       	 		 => Math , String , System => 모든 메소드를 그대로 사용
  			       	 		  종단메소드 , 종단 클래스
  			       	 abstract : 선언만 하는 메소드 ==> 구현(프로그램에 맞게 구현해서 사용)
  			       	    		버튼 클릭
  			       	    		=> 추상클래스 / 인터페이스(****)
  			       	    					 => 스프링의 기반 (결합성이 낮은 프로그램: Loosely coupling) 응집성↑:메소드
  			    리턴형 : 사용자 요청 처리한 결과값
  			    		한개만 사용 가능
  			    		=> 여러개의 값이 있는 경우 
  			    			- 같은 데이터형 여러개 (배열) ==> 컬렉션
  			    			    배열 (고정적) / 컬렉션(가변적- 원하는 갯수의 변수를 마음대로 넣을 수 있음, 지정하지 X)
  			    			- 다른 데이터형 여러개 (클래스)
  			    			    Member , Movie , Music ....
  			    		=> 한개의 결과값 : 기본형 or String
  			    		=> 결과값이 없는 경우 : 메소드 자체에서 처리 => void
  			    매개변수 : 여러개 사용 가능, 사용자 요청한 값
  			    		 -------------매개변수는 최소화를 시킨다
  			    		 			  매개변수 3개 이상이면 배열, 클래스를 이용한다
  			    구현부 : 변수가 선언되면 => 지역변수 (메소드 종료와 동시에 사라진다)
  			    		지역변수 : 초기화가 안됨 (반드시 초기화 후에 사용)
  			    		
  			    ** 변수/메소드 
  			  --------------------------------------
  				this : 클래스마다 this를 가지고 있다(static)
  					   클래스마다 자신의 객체주소를 가지고 있다
  			 class A
  			 {
  			 }
  			 A a=new A();
  			 ==> JVM  : this=a;
  			 
  			 class A
  			 {
  			  A(){ 
  			  	   this가 존재
  			  	   (this.)display 호출 가능
  			  	   ------- 생략
  			  }
  			  void display()
  			  {
  			  	this 사용 가능
  			  }
  			  static void aaa() ==> 소속이 아니고 공유하는 메소드
  			  {
  			  	//static메소드에는 this가 존재하지 않음 , 얘는 class A소속이 아니라 공유하는 소속
  			  	=> A a=new A(); ==> 객체 생성 후에 사용
  			  }
  			  
  			 }
  			 ==> 마음대로 사용할 수 있는 건 멤버변수 ,멤버메소드 , 생성자 ==> 클래스 소속
  			 A a=new A(); ==> this 有
  			 A b=new A(); ==> this 有 
  			  --------------------------------------
  			this는 멤버변수와 지역변수의 구분
  			class A
  			{
  				int age; // 지역변수는 클래스가 끝나면 사라지니까 앞에 int age처럼 선언하여 다음 메소드에서도 사용할 수 있도록 
  				public void setAge(int age) ==> 지역변수가 우선순위 (매개변수 포함)
  				{
  					age=age;	// 둘다 지역변수의 age를 가져옴. 
  					---  ---> 매개변수
  					|		
  					멤버변수
  					this.age=age;
  			 (classA에 선언된 멤버변수를 가져오는)
  				}
  			}
  			-------------------------------------------------------------------------------------------------------------
  			6장 시작
  			=> 재사용 기법
  			=> 수정과 추가
  			=> 클래스의 종류
  			--------------
  			견고한 프로그램...을.... 짜기 시작.....만들...자....
  			프로그램 조합 세가지
  			1)재사용(상속/포함) 2)가독성(메소드) 3)견고성(예외처리 능력-try cath(exception ex)~~~~blavla) 
  			
  			194page
  			-------
  			자바 상속의 특징
  			= 재사용 목적으로 사용한다 (기존의 만들어진 클래스를 확장해서 사용)
  			  ** 필요시에는 변경해서 사용 가능 (오버라이딩)
  			= 반복 코딩을 제거할 수 있다
  			  class A
  			  {
  			  	int a,b,c,d,e;
  			  	void display(){}
  			  	---
  			  	---
  			  	---
  			  }
  			  class B extends A
  			  {
  			  	void display(){} // 원하는 것만 내려서 변경할 수 있다
  			  }
  			 = 기존에 만들어진 클래스를 확장해서 새로운 클래스를 만들어서 사용
  			 예) 
  			  class 게시판
  			  {
  			  	글쓰기
  			  	목록
  			  	상세보기
  			  	수정
  			  	삭제
  			  	검색
  			  }
  			  // 확장=> 기존의 기능 사용 , 변경 , 추가
  			  class 갤러리게시판 extends 게시판
  			  {
  			  	글쓰기 => 이미지 업로드 필요함.
  			  	목록  => 이미지 출력
  			  	//상세보기
  			  	//수정
  			  	//삭제
  			  	//검색    ====> 상속 받아서 덮어쓰기 하는 기능을 오버라이딩!! (overriding)
   			  				관련된 기능은 가져가고 수정/추가해서 재사용할 수 있는 기능
  			  }
  			 // 멜론/지니뮤직/Mnet 
  			= 유지보수용. (SM)
  			= 단일 상속만 가능하다
  			= 상속 내리는 클래스: 부모클래스, 슈퍼클래스, 베이스클래스, 상위클래스
  			 
  			 상속을 받는 클래스: 자식클래스, 서브클래스, 파생클래스, 하위클래스
  			 
  			 상속이 있는 경우에는 클래스의 크기를 잴 수 있다(형변환 가능)
  			 
  			 상속을 내리는 클래스 > 상속을 받는 클래스 / A ← B (화살표는 반대로) 
  			 -------------------------------
  			 	동물
  			 	|
  			 	인간 
  			 	class Super
  			 	class Sub extends Super
  			 	-----------------------
  			 	
  			 	Sub sub=new Sub();	//파생클래스 자체로 확장.
  			 	Super super=new Sub();	// 하위클래스를 이용해서 상위클래스 생성: 상속 받았기 때문에
  			 	---------------------> 인터페이스/추상클래스 多
  			 							-------------- 미완성된 클래스라 메모리 할당을 하지 못하기 때문에 
  			 	Sub sub1=(Sub)super;	//형변환 후 사용 가능
  			 	
  			 	일반적으로 
  			 	클래스=생성자 동일한 경우가 많고
  			 	=> 클래스와 생성자가 다른 경우
  			 	=> 클래스와 메소드를 이용
  			 	 ---------------------- 인터페이스
  			 	 
  			 	 List list=new ArrayList();
  			 	 ---------인터페이스 -------구현된클래스
  			 	 Map map=new HashMap();
  			 	 ------------------------
  			 	 Connection conn=getConnection() // 생성자랑 같이 쓰는 경우 인터페이스(new를 쓰지못해서)
  			 	 
  			 ==> class A
  			 {
  			 	int a,b;
  			 	void display(){1}
  			 }
  			 class B extends A
  			 {
  			 
  			 	//int a,b
  			  	int c;
  			  	void display(){2}
  			 }
  			 
  			 A aa=new A();
  			 aa.a
  			 aa.b
  			 aa.display() ==>1
  			 
  			 B bb=new B();
  			 bb.a , bb.b , bb.c , bb.dispaly() ==> 2
  			 
  			 A aaa=new B();
  			 -	   -------
  			 변수는 A가 가지고 있는 변수만 사용이 가능
  			     생성자는 메소드를 따라간다
  			 aaa.a  aaa.b aaa.c aaa.display() ==> 2
  			 -----------  -----(X)
  			 클래스A에서 나온 
 */	
/*class Data
{
	private int a;

	public int getA() {
		return a;
	}

	public void setA(int a) {
		this.a = a;
	}
	
}
class Human
{
	Data d=new Data();		//멤버변수 (아래 public void 두개에 모두 같은 변수를 쓰고 있음)
	// static Data d=new Data(); static 여부에 따라 값이 달라짐. 왜냐? static은 메모리를 한개만 주기 때문에 아래 new로 변수를 여러개 줘도 메모리주소는 항상 동일하기 때문.
	public void getData(int a)
	{
		d.setA(a);
	}
	public void print()
	{
		System.out.println("d.a="+d.getA());
		
	}
}*/
class Super
{
	int a=10;
	int b=20;
	public void display()
	{
		System.out.println("Super가 가지고 있는 display()...");
	}
}
// Super로부터 상속을 받는다 => 예외조건) 생성자, 초기화블록, static(공유는 가능/상속은 불가능)
// private  => 상속은 가능/ 접근은 불가능 
// ------- protected 
// ------- getter/setter 
class Sub extends Super
{
	/*
	 * 	int a=10;
	int b=20;
	public void display()
	{
		System.out.println("Super가 가지고 있는 display()...");
	}
	 */
}
public class 상속_1 {

	public static void main(String[] args) {
		Sub sub=new Sub();
		
		System.out.println(sub.a);
		System.out.println(sub.b);
		
		
		// TODO Auto-generated method stub
/*		Human h=new Human();
		h.getData(100);
		h.print();
		
		Human h1=new Human();
		h1.getData(300);
		h1.print();
		
		h.print();  */

	}

}
